#version 450

// Optimized Conv2D Compute Shader for RDNA3
// =========================================
// Uses shared memory tiling for high performance

// RDNA3 optimal: 8x8 threads, each computing 2x2 outputs
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Storage buffers
layout(std430, binding = 0) readonly buffer InputBuffer {
    float data[];
} input_buf;

layout(std430, binding = 1) readonly buffer WeightBuffer {
    float data[];
} weight_buf;

layout(std430, binding = 2) buffer OutputBuffer {
    float data[];
} output_buf;

// Convolution parameters via specialization constants
layout (constant_id = 0) const int C = 64;      // Input channels
layout (constant_id = 1) const int H = 224;     // Input height
layout (constant_id = 2) const int W = 224;     // Input width
layout (constant_id = 3) const int K = 64;      // Output channels
layout (constant_id = 4) const int kernel_size = 3;
layout (constant_id = 5) const int stride = 1;
layout (constant_id = 6) const int pad = 1;
layout (constant_id = 7) const int H_out = 224; // Output height
layout (constant_id = 8) const int W_out = 224; // Output width

// Shared memory tiles
// For 8x8 workgroup computing 16x16 outputs, need 18x18 input tile
shared float tile_input[18][18];
// Share weights across workgroup
shared float tile_weight[64][3][3];  // Cache multiple output channels

void main() {
    // Thread and workgroup info
    ivec2 lid = ivec2(gl_LocalInvocationID.xy);
    ivec2 wgid = ivec2(gl_WorkGroupID.xy);
    int out_k = int(gl_WorkGroupID.z);
    
    // Each thread computes 2x2 outputs
    const int TILE_SIZE = 16;
    const int OUTPUTS_PER_THREAD = 2;
    
    // Base output position for this thread's 2x2 block
    int base_out_x = wgid.x * TILE_SIZE + lid.x * OUTPUTS_PER_THREAD;
    int base_out_y = wgid.y * TILE_SIZE + lid.y * OUTPUTS_PER_THREAD;
    
    // Initialize accumulators for 2x2 outputs
    float sum[2][2];
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            sum[i][j] = 0.0;
        }
    }
    
    // Process all input channels
    for (int c = 0; c < C; c++) {
        // Collaborative load: Load 18x18 input tile into shared memory
        // Each thread loads 2-3 values to cover the tile
        barrier();
        
        // Calculate which values this thread should load
        int tid = lid.y * 8 + lid.x;  // Thread ID in workgroup (0-63)
        
        // Load pattern: 64 threads load 324 values (18x18)
        // Each thread loads ~5 values
        for (int load_idx = tid; load_idx < 18 * 18; load_idx += 64) {
            int tile_y = load_idx / 18;
            int tile_x = load_idx % 18;
            
            // Global input position
            int in_y = wgid.y * TILE_SIZE + tile_y - pad;
            int in_x = wgid.x * TILE_SIZE + tile_x - pad;
            
            if (in_y >= 0 && in_y < H && in_x >= 0 && in_x < W) {
                tile_input[tile_y][tile_x] = input_buf.data[c * H * W + in_y * W + in_x];
            } else {
                tile_input[tile_y][tile_x] = 0.0;  // Padding
            }
        }
        
        // Load weights for this channel (3x3 kernel)
        if (tid < 9) {
            int ky = tid / 3;
            int kx = tid % 3;
            tile_weight[0][ky][kx] = weight_buf.data[out_k * C * 9 + c * 9 + tid];
        }
        
        // Synchronize after loading
        barrier();
        
        // Compute convolution for 2x2 outputs using shared memory
        for (int oy = 0; oy < 2; oy++) {
            for (int ox = 0; ox < 2; ox++) {
                // Output position in tile
                int out_y = lid.y * 2 + oy;
                int out_x = lid.x * 2 + ox;
                
                // Convolve with 3x3 kernel
                for (int ky = 0; ky < 3; ky++) {
                    for (int kx = 0; kx < 3; kx++) {
                        sum[oy][ox] += tile_input[out_y + ky][out_x + kx] * tile_weight[0][ky][kx];
                    }
                }
            }
        }
    }
    
    // Write 2x2 outputs to global memory
    for (int oy = 0; oy < 2; oy++) {
        for (int ox = 0; ox < 2; ox++) {
            int out_y = base_out_y + oy;
            int out_x = base_out_x + ox;
            
            if (out_x < W_out && out_y < H_out) {
                int output_idx = out_k * H_out * W_out + out_y * W_out + out_x;
                output_buf.data[output_idx] = sum[oy][ox];
            }
        }
    }
}