#version 450

// Universal pattern convolution shader for NVIDIA GPUs
// Optimized based on hardware profiler discoveries

// Optimal parameters from profiler:
// - Block size: 128 threads (4 warps)
// - Tile size: 32×32 
// - Outputs per thread: 4×4
// - Unroll factor: 16×
// - Use shared memory: Yes

layout(local_size_x = 32, local_size_y = 4, local_size_z = 1) in; // 128 threads total

// Buffers
layout(std430, binding = 0) readonly buffer InputBuffer {
    float input[];
};

layout(std430, binding = 1) readonly buffer KernelBuffer {
    float kernel[];
};

layout(std430, binding = 2) writeonly buffer OutputBuffer {
    float output[];
};

// Uniforms
uniform int batch;
uniform int in_channels;
uniform int out_channels;
uniform int height;
uniform int width;
uniform int kernel_h;
uniform int kernel_w;
uniform int out_height;
uniform int out_width;

// Shared memory for tile-based computation
// 32×32 tile with double buffering = 2×32×32×4 = 8KB
shared float tile_input[32][32];
shared float tile_kernel[32][32];

void main() {
    // Thread indices
    uint tid_x = gl_LocalInvocationID.x;
    uint tid_y = gl_LocalInvocationID.y;
    uint block_x = gl_WorkGroupID.x;
    uint block_y = gl_WorkGroupID.y;
    uint block_z = gl_WorkGroupID.z;
    
    // Each thread computes 4×4 outputs
    const int OUTPUTS_PER_THREAD = 4;
    const int TILE_SIZE = 32;
    
    // Output tile position
    int out_y_base = int(block_y) * TILE_SIZE;
    int out_x_base = int(block_x) * TILE_SIZE;
    int out_c = int(block_z);
    
    // Thread's output position within tile
    int thread_out_y = int(tid_y) * (TILE_SIZE / 4);  // 4 warps in Y
    int thread_out_x = int(tid_x);
    
    // Initialize accumulators for 4×4 outputs
    float acc[OUTPUTS_PER_THREAD][OUTPUTS_PER_THREAD];
    for (int i = 0; i < OUTPUTS_PER_THREAD; i++) {
        for (int j = 0; j < OUTPUTS_PER_THREAD; j++) {
            acc[i][j] = 0.0;
        }
    }
    
    // Main convolution loop - process all input channels
    for (int ic = 0; ic < in_channels; ic++) {
        
        // Process kernel positions
        for (int ky = 0; ky < kernel_h; ky++) {
            for (int kx = 0; kx < kernel_w; kx++) {
                
                // Collaborative load input tile to shared memory
                barrier();
                
                // Each thread loads one element
                int load_y = thread_out_y + out_y_base + ky;
                int load_x = thread_out_x + out_x_base + kx;
                
                if (load_y < height && load_x < width) {
                    int input_idx = ((0 * in_channels + ic) * height + load_y) * width + load_x;
                    tile_input[thread_out_y][thread_out_x] = input[input_idx];
                }
                
                // Load kernel weight (broadcast to all threads processing same output channel)
                if (tid_x == 0 && tid_y == 0) {
                    int kernel_idx = ((out_c * in_channels + ic) * kernel_h + ky) * kernel_w + kx;
                    tile_kernel[0][0] = kernel[kernel_idx];
                }
                
                barrier();
                
                // Compute 4×4 outputs using shared memory
                float k_val = tile_kernel[0][0];
                
                // Unroll the computation loop 16× as recommended
                #pragma unroll 4
                for (int dy = 0; dy < OUTPUTS_PER_THREAD; dy++) {
                    #pragma unroll 4
                    for (int dx = 0; dx < OUTPUTS_PER_THREAD; dx++) {
                        int sy = thread_out_y + dy;
                        int sx = thread_out_x + dx * 8; // Stride in X for 4 outputs
                        
                        if (sy < TILE_SIZE && sx < TILE_SIZE) {
                            acc[dy][dx] += tile_input[sy][sx] * k_val;
                        }
                    }
                }
            }
        }
    }
    
    // Write 4×4 outputs to global memory
    for (int dy = 0; dy < OUTPUTS_PER_THREAD; dy++) {
        for (int dx = 0; dx < OUTPUTS_PER_THREAD; dx++) {
            int out_y = out_y_base + thread_out_y + dy;
            int out_x = out_x_base + thread_out_x + dx * 8;
            
            if (out_y < out_height && out_x < out_width) {
                int output_idx = ((0 * out_channels + out_c) * out_height + out_y) * out_width + out_x;
                output[output_idx] = acc[dy][dx];
            }
        }
    }
}